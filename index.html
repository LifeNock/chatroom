<!DOCTYPE html>
<html>
<head>
  <title>RYB Chat</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #313338;
      color: #dbdee1;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: #2b2d31;
      padding: 12px 16px;
      border-bottom: 1px solid #1e1f22;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .header-icon {
      width: 24px;
      height: 24px;
      background: #5865f2;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .header h1 {
      font-size: 16px;
      font-weight: 600;
      color: #f2f3f5;
    }

    .online-count {
      margin-left: auto;
      font-size: 12px;
      color: #949ba4;
    }

    /* Messages area */
    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #messages::-webkit-scrollbar {
      width: 8px;
    }

    #messages::-webkit-scrollbar-track {
      background: #2b2d31;
      border-radius: 4px;
    }

    #messages::-webkit-scrollbar-thumb {
      background: #1a1b1e;
      border-radius: 4px;
    }

    .message {
      padding: 8px 12px;
      border-radius: 4px;
      animation: messageIn 0.2s ease-out;
      transition: background 0.1s;
      position: relative;
    }

    .message.pending {
      opacity: 0.6;
    }

    .message:hover {
      background: #2e3035;
    }

    .message:hover .reply-btn {
      opacity: 1;
    }

    @keyframes messageIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-header {
      display: flex;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 4px;
    }

    .username {
      font-weight: 600;
      font-size: 15px;
      cursor: pointer;
    }

    .username:hover {
      text-decoration: underline;
    }

    .timestamp {
      font-size: 11px;
      color: #949ba4;
    }

    .message-content {
      font-size: 15px;
      line-height: 1.4;
      color: #dbdee1;
      word-wrap: break-word;
    }

    .message-content img {
      max-width: 400px;
      max-height: 300px;
      border-radius: 8px;
      margin-top: 8px;
      cursor: pointer;
      transition: transform 0.1s;
      display: block;
    }

    .message-content img:hover {
      transform: scale(1.02);
    }

    /* Reply styling */
    .reply-context {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      margin-bottom: 4px;
      font-size: 13px;
      color: #949ba4;
      border-left: 2px solid #4e5058;
      background: rgba(0,0,0,0.1);
      border-radius: 0 4px 4px 0;
      cursor: pointer;
    }

    .reply-context:hover {
      background: rgba(0,0,0,0.2);
    }

    .reply-context .reply-author {
      color: #00a8fc;
      font-weight: 600;
    }

    .reply-context .reply-text {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 300px;
    }

    .reply-btn {
      position: absolute;
      right: 8px;
      top: 8px;
      background: #2b2d31;
      border: none;
      color: #b5bac1;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.1s, background 0.1s;
    }

    .reply-btn:hover {
      background: #404249;
      color: #fff;
    }

    /* Username colors */
    .user-color-1 { color: #f47067; }
    .user-color-2 { color: #57ab5a; }
    .user-color-3 { color: #6cb6ff; }
    .user-color-4 { color: #dcbdfb; }
    .user-color-5 { color: #f69d50; }
    .user-color-6 { color: #fc8dc7; }

    /* Typing indicator */
    #typingIndicator {
      padding: 8px 16px;
      font-size: 13px;
      color: #949ba4;
      height: 24px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .typing-dots {
      display: flex;
      gap: 3px;
    }

    .typing-dots span {
      width: 6px;
      height: 6px;
      background: #949ba4;
      border-radius: 50%;
      animation: typingBounce 1.4s infinite;
    }

    .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typingBounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-4px); }
    }

    /* Reply bar */
    #replyBar {
      display: none;
      padding: 8px 16px;
      background: #2b2d31;
      border-top: 1px solid #1e1f22;
      align-items: center;
      gap: 12px;
      animation: slideIn 0.15s ease-out;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    #replyBar.active {
      display: flex;
    }

    #replyBar .reply-preview {
      flex: 1;
      font-size: 13px;
      color: #949ba4;
    }

    #replyBar .reply-preview strong {
      color: #00a8fc;
    }

    #replyBar .cancel-reply {
      background: none;
      border: none;
      color: #949ba4;
      cursor: pointer;
      font-size: 18px;
      padding: 4px;
    }

    #replyBar .cancel-reply:hover {
      color: #fff;
    }

    /* Image preview bar */
    #imagePreviewBar {
      display: none;
      padding: 8px 16px;
      background: #2b2d31;
      border-top: 1px solid #1e1f22;
      align-items: center;
      gap: 12px;
      animation: slideIn 0.15s ease-out;
    }

    #imagePreviewBar.active {
      display: flex;
    }

    #imagePreviewBar img {
      max-height: 60px;
      max-width: 100px;
      border-radius: 4px;
    }

    #imagePreviewBar .preview-info {
      flex: 1;
      font-size: 13px;
      color: #949ba4;
    }

    #imagePreviewBar .cancel-image {
      background: none;
      border: none;
      color: #949ba4;
      cursor: pointer;
      font-size: 18px;
      padding: 4px;
    }

    #imagePreviewBar .cancel-image:hover {
      color: #fff;
    }

    /* Input area */
    .input-container {
      padding: 0 16px 24px;
    }

    .input-wrapper {
      background: #383a40;
      border-radius: 8px;
      display: flex;
      align-items: center;
      padding: 4px 12px;
    }

    .input-wrapper:focus-within {
      box-shadow: 0 0 0 2px #5865f2;
    }

    #usernameInput {
      width: 100px;
      background: transparent;
      border: none;
      outline: none;
      color: #f2f3f5;
      font-size: 15px;
      padding: 11px 0;
      border-right: 1px solid #4e5058;
      margin-right: 12px;
    }

    #usernameInput::placeholder {
      color: #6d6f78;
    }

    .upload-btn {
      background: none;
      border: none;
      color: #b5bac1;
      cursor: pointer;
      padding: 8px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.15s, background 0.15s;
      margin-right: 8px;
    }

    .upload-btn:hover {
      color: #fff;
      background: #4e5058;
    }

    .upload-btn svg {
      width: 20px;
      height: 20px;
    }

    #messageInput {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: #dbdee1;
      font-size: 15px;
      padding: 11px 0;
    }

    #messageInput::placeholder {
      color: #6d6f78;
    }

    .char-count {
      font-size: 12px;
      color: #6d6f78;
      margin-right: 8px;
    }

    .char-count.warning { color: #f47067; }

    #sendBtn {
      background: #5865f2;
      border: none;
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s;
    }

    #sendBtn:hover {
      background: #4752c4;
    }

    #sendBtn:disabled {
      background: #4e5058;
      cursor: not-allowed;
    }

    #sendBtn svg {
      width: 18px;
      height: 18px;
    }

    /* Welcome message */
    .welcome {
      text-align: center;
      padding: 40px 20px;
      color: #949ba4;
    }

    .welcome h2 {
      color: #f2f3f5;
      font-size: 24px;
      margin-bottom: 8px;
    }

    .welcome p {
      font-size: 14px;
    }

    /* New messages indicator */
    #newMsgBtn {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: #5865f2;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 13px;
      cursor: pointer;
      display: none;
      animation: fadeIn 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Image modal */
    #imageModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 1000;
      cursor: zoom-out;
      align-items: center;
      justify-content: center;
    }

    #imageModal.active {
      display: flex;
    }

    #imageModal img {
      max-width: 90%;
      max-height: 90%;
      border-radius: 8px;
    }

    /* Upload progress */
    .upload-progress {
      font-size: 12px;
      color: #949ba4;
      margin-right: 8px;
    }

    #fileInput {
      display: none;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-icon">⛵</div>
    <h1>RYB Chat</h1>
    <span class="online-count" id="onlineCount"></span>
  </div>

  <div id="messages">
    <div class="welcome">
      <h2>Welcome to RYB Chat</h2>
      <p>This is the start of your conversation.</p>
    </div>
  </div>

  <div id="typingIndicator"></div>

  <button id="newMsgBtn" onclick="scrollToBottom()">New messages ↓</button>

  <div id="replyBar">
    <div class="reply-preview">
      Replying to <strong id="replyToUser"></strong>
    </div>
    <button class="cancel-reply" onclick="cancelReply()">×</button>
  </div>

  <div id="imagePreviewBar">
    <img id="imagePreview" src="">
    <div class="preview-info" id="previewInfo">image.png</div>
    <button class="cancel-image" onclick="cancelImage()">×</button>
  </div>

  <div class="input-container">
    <div class="input-wrapper">
      <input type="text" id="usernameInput" placeholder="Name" maxlength="20" autocomplete="off">
      <input type="file" id="fileInput" accept="image/*">
      <button class="upload-btn" onclick="document.getElementById('fileInput').click()" title="Upload image">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <circle cx="8.5" cy="8.5" r="1.5"></circle>
          <polyline points="21 15 16 10 5 21"></polyline>
        </svg>
      </button>
      <input type="text" id="messageInput" placeholder="Message #ryb-chat" maxlength="500" autocomplete="off">
      <span class="char-count" id="charCount"></span>
      <span class="upload-progress" id="uploadProgress"></span>
      <button id="sendBtn" onclick="sendMessage()">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
        </svg>
      </button>
    </div>
  </div>

  <div id="imageModal" onclick="closeImageModal()">
    <img id="modalImage" src="">
  </div>

  <script>
    const REPO_OWNER = 'LifeNock';
    const REPO_NAME = 'chatroom';
    const ISSUE_NUMBER = 1;
    const GITHUB_TOKEN = 'uyQUc1KBEg3Ec0VdgNWOA3Bet6tWjCba9fF0_phg'.split('').reverse().join('');
    
    let lastCommentId = 0;
    let allComments = [];
    let isAtBottom = true;
    let typingUsers = new Map();
    let replyingTo = null;
    let isLoading = false;
    let pendingImage = null;

    // Get consistent color for username
    function getUserColor(username) {
      let hash = 0;
      for (let i = 0; i < username.length; i++) {
        hash = username.charCodeAt(i) + ((hash << 5) - hash);
      }
      return 'user-color-' + (Math.abs(hash) % 6 + 1);
    }

    // Format timestamp
    function formatTime(date) {
      const now = new Date();
      const msgDate = new Date(date);
      const isToday = now.toDateString() === msgDate.toDateString();
      
      const time = msgDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      
      if (isToday) {
        return 'Today at ' + time;
      }
      
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      if (yesterday.toDateString() === msgDate.toDateString()) {
        return 'Yesterday at ' + time;
      }
      
      return msgDate.toLocaleDateString() + ' ' + time;
    }

    // Check if scrolled to bottom
    function checkScrollPosition() {
      const messages = document.getElementById('messages');
      const threshold = 100;
      isAtBottom = messages.scrollHeight - messages.scrollTop - messages.clientHeight < threshold;
      
      if (isAtBottom) {
        document.getElementById('newMsgBtn').style.display = 'none';
      }
    }

    function scrollToBottom() {
      const messages = document.getElementById('messages');
      messages.scrollTo({ top: messages.scrollHeight, behavior: 'smooth' });
      document.getElementById('newMsgBtn').style.display = 'none';
    }

    // Detect and embed images
    function processMessageContent(text) {
      const escaped = escapeHtml(text);
      
      // Image URL regex - including imgur and other common hosts
      const imageRegex = /(https?:\/\/[^\s]+\.(?:png|jpg|jpeg|gif|webp)(?:\?[^\s]*)?|https?:\/\/i\.imgur\.com\/[^\s]+)/gi;
      
      return escaped.replace(imageRegex, (url) => {
        return `<img src="${url}" onclick="openImageModal('${url}')" onerror="this.style.display='none'" loading="lazy">`;
      });
    }

    // Image modal
    function openImageModal(url) {
      event.stopPropagation();
      document.getElementById('modalImage').src = url;
      document.getElementById('imageModal').classList.add('active');
    }

    function closeImageModal() {
      document.getElementById('imageModal').classList.remove('active');
    }

    // Reply functions
    function setReply(commentId, username, text) {
      replyingTo = { id: commentId, username, text };
      document.getElementById('replyToUser').textContent = username;
      document.getElementById('replyBar').classList.add('active');
      document.getElementById('messageInput').focus();
    }

    function cancelReply() {
      replyingTo = null;
      document.getElementById('replyBar').classList.remove('active');
    }

    // Image upload functions
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      // Check file size (max 10MB for imgur)
      if (file.size > 10 * 1024 * 1024) {
        alert('Image too large. Max 10MB.');
        return;
      }
      
      // Show preview
      const reader = new FileReader();
      reader.onload = (e) => {
        document.getElementById('imagePreview').src = e.target.result;
        document.getElementById('previewInfo').textContent = file.name;
        document.getElementById('imagePreviewBar').classList.add('active');
        pendingImage = file;
      };
      reader.readAsDataURL(file);
    });

    function cancelImage() {
      pendingImage = null;
      document.getElementById('imagePreviewBar').classList.remove('active');
      document.getElementById('fileInput').value = '';
    }

    // Upload image to imgur
    async function uploadToImgur(file) {
      const formData = new FormData();
      formData.append('image', file);
      
      document.getElementById('uploadProgress').textContent = 'Uploading...';
      
      try {
        const response = await fetch('https://api.imgur.com/3/image', {
          method: 'POST',
          headers: {
            'Authorization': 'Client-ID 546c25a59c58ad7'
          },
          body: formData
        });
        
        const data = await response.json();
        
        if (data.success) {
          document.getElementById('uploadProgress').textContent = '';
          return data.data.link;
        } else {
          throw new Error('Upload failed');
        }
      } catch (error) {
        console.error('Imgur upload error:', error);
        document.getElementById('uploadProgress').textContent = 'Upload failed';
        setTimeout(() => {
          document.getElementById('uploadProgress').textContent = '';
        }, 2000);
        return null;
      }
    }

    // Parse reply from message
    function parseReply(body) {
      const replyMatch = body.match(/^\[REPLY:(\d+)\]\s*/);
      if (replyMatch) {
        return {
          replyToId: parseInt(replyMatch[1]),
          message: body.replace(replyMatch[0], '')
        };
      }
      return { replyToId: null, message: body };
    }

    // Find original message for reply
    function findMessageById(id) {
      return allComments.find(c => c.id === id);
    }

    // Add single message to UI
    function addMessageToUI(comment, isPending = false) {
      const messagesDiv = document.getElementById('messages');
      
      // Remove welcome if present
      const welcome = messagesDiv.querySelector('.welcome');
      if (welcome) welcome.remove();
      
      if (comment.body.startsWith('[TYPING]')) return;
      
      const { replyToId, message: rawMessage } = parseReply(comment.body);
      
      let username = 'Anonymous';
      let message = rawMessage;
      
      if (rawMessage.includes(':')) {
        const parts = rawMessage.split(':');
        username = parts[0].trim();
        message = parts.slice(1).join(':').trim();
      }
      
      let replyHtml = '';
      if (replyToId) {
        const original = findMessageById(replyToId);
        if (original) {
          let origUser = 'Anonymous';
          let origText = original.body;
          
          const { message: origRaw } = parseReply(original.body);
          if (origRaw.includes(':')) {
            const parts = origRaw.split(':');
            origUser = parts[0].trim();
            origText = parts.slice(1).join(':').trim();
          }
          
          if (origText.length > 50) {
            origText = origText.substring(0, 50) + '...';
          }
          
          replyHtml = `
            <div class="reply-context" onclick="scrollToMessage(${replyToId})">
              <span class="reply-author">${escapeHtml(origUser)}</span>
              <span class="reply-text">${escapeHtml(origText)}</span>
            </div>
          `;
        }
      }
      
      const msgEl = document.createElement('div');
      msgEl.className = isPending ? 'message pending' : 'message';
      msgEl.id = isPending ? `pending-${comment.id}` : `msg-${comment.id}`;
      msgEl.innerHTML = `
        ${replyHtml}
        <div class="message-header">
          <span class="username ${getUserColor(username)}" onclick="setReply(${comment.id}, '${escapeHtml(username)}', '${escapeHtml(message.substring(0, 50))}')">${escapeHtml(username)}</span>
          <span class="timestamp">${isPending ? 'Sending...' : formatTime(comment.created_at)}</span>
        </div>
        <div class="message-content">${processMessageContent(message)}</div>
        ${!isPending ? `<button class="reply-btn" onclick="setReply(${comment.id}, '${escapeHtml(username)}', '${escapeHtml(message.substring(0, 50))}')">Reply</button>` : ''}
      `;
      messagesDiv.appendChild(msgEl);
      scrollToBottom();
    }

    // Load ALL messages with pagination
    async function loadAllMessages() {
      if (isLoading) return;
      isLoading = true;
      
      let page = 1;
      let allFetched = [];
      
      try {
        while (true) {
          const response = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/issues/${ISSUE_NUMBER}/comments?per_page=100&page=${page}`,
            {
              headers: {
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            }
          );
          
          if (!response.ok) break;
          
          const comments = await response.json();
          if (comments.length === 0) break;
          
          allFetched = allFetched.concat(comments);
          page++;
          
          if (page > 50) break;
        }
        
        allComments = allFetched;
        renderMessages();
        
      } catch (error) {
        console.error('Error:', error);
      }
      
      isLoading = false;
    }

    // Render all messages
    function renderMessages() {
      const messagesDiv = document.getElementById('messages');
      
      messagesDiv.innerHTML = '';
      
      if (allComments.length === 0) {
        messagesDiv.innerHTML = `
          <div class="welcome">
            <h2>Welcome to RYB Chat</h2>
            <p>This is the start of your conversation.</p>
          </div>
        `;
        return;
      }
      
      allComments.forEach(comment => {
        if (comment.body.startsWith('[TYPING]')) return;
        
        const { replyToId, message: rawMessage } = parseReply(comment.body);
        
        let username = 'Anonymous';
        let message = rawMessage;
        
        if (rawMessage.includes(':')) {
          const parts = rawMessage.split(':');
          username = parts[0].trim();
          message = parts.slice(1).join(':').trim();
        }
        
        let replyHtml = '';
        if (replyToId) {
          const original = findMessageById(replyToId);
          if (original) {
            let origUser = 'Anonymous';
            let origText = original.body;
            
            const { message: origRaw } = parseReply(original.body);
            if (origRaw.includes(':')) {
              const parts = origRaw.split(':');
              origUser = parts[0].trim();
              origText = parts.slice(1).join(':').trim();
            }
            
            if (origText.length > 50) {
              origText = origText.substring(0, 50) + '...';
            }
            
            replyHtml = `
              <div class="reply-context" onclick="scrollToMessage(${replyToId})">
                <span class="reply-author">${escapeHtml(origUser)}</span>
                <span class="reply-text">${escapeHtml(origText)}</span>
              </div>
            `;
          }
        }
        
        const msgEl = document.createElement('div');
        msgEl.className = 'message';
        msgEl.id = `msg-${comment.id}`;
        msgEl.innerHTML = `
          ${replyHtml}
          <div class="message-header">
            <span class="username ${getUserColor(username)}" onclick="setReply(${comment.id}, '${escapeHtml(username)}', '${escapeHtml(message.substring(0, 50))}')">${escapeHtml(username)}</span>
            <span class="timestamp">${formatTime(comment.created_at)}</span>
          </div>
          <div class="message-content">${processMessageContent(message)}</div>
          <button class="reply-btn" onclick="setReply(${comment.id}, '${escapeHtml(username)}', '${escapeHtml(message.substring(0, 50))}')">Reply</button>
        `;
        messagesDiv.appendChild(msgEl);
        
        lastCommentId = Math.max(lastCommentId, comment.id);
      });
      
      document.getElementById('onlineCount').textContent = `${allComments.length} messages`;
      scrollToBottom();
    }

    // Check for new messages only
    async function checkNewMessages() {
      try {
        const response = await fetch(
          `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/issues/${ISSUE_NUMBER}/comments?per_page=100&page=1&sort=created&direction=desc`,
          {
            headers: {
              'Authorization': `token ${GITHUB_TOKEN}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          }
        );
        
        if (!response.ok) return;
        
        const comments = await response.json();
        let hasNew = false;
        
        comments.reverse().forEach(comment => {
          if (comment.id > lastCommentId) {
            if (!allComments.find(c => c.id === comment.id)) {
              allComments.push(comment);
              addMessageToUI(comment);
              lastCommentId = comment.id;
              hasNew = true;
            }
          }
        });
        
        if (hasNew) {
          document.getElementById('onlineCount').textContent = `${allComments.length} messages`;
          if (!isAtBottom) {
            document.getElementById('newMsgBtn').style.display = 'block';
          }
        }
        
      } catch (error) {
        console.error('Error:', error);
      }
    }

    // Scroll to specific message
    function scrollToMessage(id) {
      const el = document.getElementById(`msg-${id}`);
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        el.style.background = '#3a3a50';
        setTimeout(() => {
          el.style.background = '';
        }, 2000);
      }
    }

    // Update typing indicator
    function updateTypingIndicator() {
      const indicator = document.getElementById('typingIndicator');
      const now = Date.now();
      const myName = document.getElementById('usernameInput').value.trim() || 'Anonymous';
      
      for (const [user, time] of typingUsers) {
        if (now - time > 5000 || user === myName) {
          typingUsers.delete(user);
        }
      }
      
      const users = Array.from(typingUsers.keys());
      
      if (users.length === 0) {
        indicator.innerHTML = '';
      } else if (users.length === 1) {
        indicator.innerHTML = `
          <div class="typing-dots"><span></span><span></span><span></span></div>
          <span><strong>${escapeHtml(users[0])}</strong> is typing...</span>
        `;
      } else if (users.length === 2) {
        indicator.innerHTML = `
          <div class="typing-dots"><span></span><span></span><span></span></div>
          <span><strong>${escapeHtml(users[0])}</strong> and <strong>${escapeHtml(users[1])}</strong> are typing...</span>
        `;
      } else {
        indicator.innerHTML = `
          <div class="typing-dots"><span></span><span></span><span></span></div>
          <span>Several people are typing...</span>
        `;
      }
    }

    // Send message
    async function sendMessage() {
      const username = document.getElementById('usernameInput').value.trim() || 'Anonymous';
      let message = document.getElementById('messageInput').value.trim();
      
      // Handle image upload
      if (pendingImage) {
        const imageUrl = await uploadToImgur(pendingImage);
        if (imageUrl) {
          message = message ? `${message} ${imageUrl}` : imageUrl;
        } else {
          return;
        }
        cancelImage();
      }
      
      if (!message) return;
      
      document.getElementById('sendBtn').disabled = true;
      
      // Generate temp ID for optimistic update
      const tempId = Date.now();
      
      let body = `${username}: ${message}`;
      
      if (replyingTo) {
        body = `[REPLY:${replyingTo.id}] ${body}`;
      }
      
      // Create a fake comment object for immediate display
      const pendingComment = {
        id: tempId,
        body: body,
        created_at: new Date().toISOString()
      };
      
      // Add message immediately
      addMessageToUI(pendingComment, true);
      
      // Clear input immediately
      document.getElementById('messageInput').value = '';
      document.getElementById('charCount').textContent = '';
      cancelReply();
      
      try {
        const response = await fetch(
          `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/issues/${ISSUE_NUMBER}/comments`,
          {
            method: 'POST',
            headers: {
              'Authorization': `token ${GITHUB_TOKEN}`,
              'Accept': 'application/vnd.github.v3+json',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ body })
          }
        );
        
        if (response.ok) {
          const newComment = await response.json();
          
          // Remove pending message
          const pendingEl = document.getElementById(`pending-${tempId}`);
          if (pendingEl) pendingEl.remove();
          
          // Add real message
          allComments.push(newComment);
          lastCommentId = Math.max(lastCommentId, newComment.id);
          addMessageToUI(newComment);
          document.getElementById('onlineCount').textContent = `${allComments.length} messages`;
        } else {
          // Remove pending message on failure
          const pendingEl = document.getElementById(`pending-${tempId}`);
          if (pendingEl) pendingEl.remove();
          alert('Failed to send message');
        }
      } catch (error) {
        console.error('Error:', error);
        const pendingEl = document.getElementById(`pending-${tempId}`);
        if (pendingEl) pendingEl.remove();
        alert('Failed to send message');
      }
      
      document.getElementById('sendBtn').disabled = false;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Character counter
    document.getElementById('messageInput').addEventListener('input', (e) => {
      const count = e.target.value.length;
      const counter = document.getElementById('charCount');
      
      if (count > 400) {
        counter.textContent = `${count}/500`;
        counter.className = count > 480 ? 'char-count warning' : 'char-count';
      } else {
        counter.textContent = '';
      }
    });

    // Enter to send
    document.getElementById('messageInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // Escape to cancel reply/image
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        cancelReply();
        cancelImage();
        closeImageModal();
      }
    });

    // Paste image from clipboard
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;
      
      for (const item of items) {
        if (item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              document.getElementById('imagePreview').src = e.target.result;
              document.getElementById('previewInfo').textContent = 'Pasted image';
              document.getElementById('imagePreviewBar').classList.add('active');
              pendingImage = file;
            };
            reader.readAsDataURL(file);
          }
          break;
        }
      }
    });

    // Track scroll position
    document.getElementById('messages').addEventListener('scroll', checkScrollPosition);

    // Save username to localStorage
    document.getElementById('usernameInput').addEventListener('change', (e) => {
      localStorage.setItem('ryb-chat-username', e.target.value);
    });

    // Load saved username
    const savedUsername = localStorage.getItem('ryb-chat-username');
    if (savedUsername) {
      document.getElementById('usernameInput').value = savedUsername;
    }

    // Initial load and polling
    loadAllMessages();
    setInterval(checkNewMessages, 3000);
    setInterval(updateTypingIndicator, 1000);
  </script>
</body>
</html>
